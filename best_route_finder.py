# -*- coding: utf-8 -*-
"""Best Route Finder.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qe01GOtkwNppOAR_QQ6D07Zkf1sEqJFi

##Encontrar la mejor Ruta, utilizando Nodos y árboles, así como funciones Heurísticas ajustadas costos definidos por el usuario.
"""

!pip install plotly_express
!pip install googlemaps
!pip install osmnx
!pip install requests
!pip install haversine

#conda install -c conda-forge geopy
#conda install -c plotly plotly_express
#conda install -c conda-forge osmnx

from geopy.distance import geodesic
import pandas as pd
import geopandas as gpd
from shapely.geometry import Point, LineString
from datetime import datetime
from haversine import haversine, Unit

import matplotlib.pyplot as plt
import plotly_express as px

import networkx as nx
import osmnx as ox
import googlemaps
import requests
import random

import pydot
from IPython.display import Image, display
import queue
import numpy as np
import re

"""Para este ejemplo utilizaremos un mapa de Bello."""

#G = ox.graph_from_place('Envigado, Antioquia, Colombia', network_type='drive',simplify=False, )

#G = ox.graph.graph_from_bbox(6.183974,6.169190, -75.599621, -75.582112, network_type='drive',simplify=False) #Envigado
#G = ox.graph.graph_from_bbox(6.3285009,6.1037654, -75.613129, -75.484842, network_type='drive',simplify=False) #MEVAL
#geo_file_path = "areametro.GraphML"
#G = ox.load_graphml(geo_file_path)
#G = ox.graph_from_place('Bello, Antioquia, Colombia', network_type='drive',simplify=False)
G = ox.graph.graph_from_bbox(6.3495989,6.3144015, -76.5617645, -75.532848, network_type='drive',simplify=False) #BELLO

ox.plot_graph(G,figsize=(50,50))

hwy_speeds = {'residential': 35,
              'secondary': 50,
              'tertiary': 60}
G = ox.add_edge_speeds(G,hwy_speeds)
G = ox.add_edge_travel_times(G)

gdf_nodes, gdf_edges = ox.graph_to_gdfs(G)

"""# Esta función nos permitirá encontrar la diferencia de altitud entre dos nodos."""

def getHeight(currentNode, targetNode):

  baseURl = "https://api.open-elevation.com/api/v1/lookup?locations="

  pos_xy_cnode = str(gdf_nodes.loc[currentNode][['x','y']].values.tolist()[::-1])
  pos_xy_cnode = re.sub("\[|\]|\ ","",pos_xy_cnode)
  URL = baseURl+pos_xy_cnode
  response_cnode = requests.get(URL)
  height_cnode = response_cnode.json()
  height_cnode = height_cnode['results'][0]['elevation']

  pos_xy_tnode = str(gdf_nodes.loc[targetNode][['x','y']].values.tolist()[::-1])
  pos_xy_tnode = re.sub("\[|\]|\ ","",pos_xy_tnode)
  URL = baseURl+pos_xy_tnode
  response_tnode = requests.get(URL)
  height_tnode = response_tnode.json()
  height_tnode = height_tnode['results'][0]['elevation']

  return height_tnode - height_cnode

class Node ():
  def __init__(self, state,value,operators,operator=None, modo=None, target=None, parent=None,objective=None):
    self.state= state
    self.value = value
    self.children = []
    self.parent=parent
    self.operator=operator
    self.objective=objective
    self.level=0
    self.operators=operators
    self.modo = modo
    self.target = target


  def add_child(self, value, state, operator, modo, target, objective):
    node=type(self)(value=value, state=state, operator=operator, modo=modo, target=target, parent=self,operators=self.operators,objective=self.objective)
    node.level=node.parent.level+1
    self.children.append(node)
    return node

  def add_node_child(self, node):
    node.level=node.parent.level+1
    self.children.append(node)
    return node

  def getchildrens(self):

    return [self.getState(i) if not self.repeatStatePath(self.getState(i)) else None for i, op in enumerate(self.operators)]

  def getState(self, index):
    pass

  def __eq__(self, other):
    return self.value == other.value

  def __lt__(self, other):
    return self.f() < other.f()


  def repeatStatePath(self, state):
      n=self
      while n is not None and n.state!=state:
          n=n.parent
      return n is not None

  def pathObjective(self):
      n=self
      result=[]
      while n is not None:
          result.append(n)
          n=n.parent
      return result

  def heuristic(self):

    return 0

  def cost(self):
    return 1

  def f(self):
    return self.cost()+self.heuristic()

class Tree ():
  def __init__(self, root ,operators):
    self.root=root
    self.operators=operators
    self.ruta = []

  def printPath(self,n):
    stack=n.pathObjective()
    path=stack.copy()
    while len(stack)!=0:
        node=stack.pop()
        if node.operator is not None:
            self.ruta.append(node.state)
        else:
            print(f' {node.state}')
    return path

  def reinitRoot(self):
    self.root.operator=None
    self.root.parent=None
    self.root.objective=None
    self.root.children = []
    self.root.level=0

  ## Primero a lo ancho
  def breadthFirst(self,endState):
    self.reinitRoot()
    pq=queue.Queue()
    pq.put(self.root)
    while not pq.empty():
      node=pq.get()
      children=node.getchildrens()
      for i,child in enumerate(children):
        if child is not None:
          newChild=node.add_child(value=node.value+'-'+str(i), state=child, operator=i)
          pq.put(newChild)
          if endState==child:
            return newChild

  ## Primero en profundidad
  def dephFirst(self, endState):
    self.reinitRoot()
    pq=[]
    pq.append(self.root)
    while len(pq)>0:
      node=pq.pop()
      if (node.parent is not None):
        node.parent.add_node_child(node)
      children=node.getchildrens()
      temp=[]
      for i,child in enumerate(children):
        if child is not None:
          newChild=type(self.root)(value=node.value+'-'+str(i),state=child,operator=i, parent=node,
                                   operators=node.operators)
          temp.append(newChild)
          if endState==child:
            node.add_node_child(newChild)
            return newChild
      #Adicionar los hijos en forma inversa para que salga primero el primero que se adicionó
      temp.reverse()
      for e in temp:
        pq.append(e)

  ## Costo uniforme
  def costUniform(self,endState):
    self.reinitRoot()
    pq=queue.PriorityQueue()
    pq.put((self.root.cost(),self.root))
    while not pq.empty():
      node=pq.get()[1]
      children=node.getchildrens()
      for i,child in enumerate(children):
        if child is not None:
          newChild=node.add_child(value=node.value+'-'+str(i),
                                  state=child, operator=i)
          pq.put((newChild.cost(),newChild))
          if endState==child:
            return newChild

  ## Primero el mejor
  def bestFirst(self,endState):
    self.reinitRoot()
    pq=queue.PriorityQueue()
    pq.put((self.root.heuristic(),self.root))
    while not pq.empty():
      node=pq.get()[1]
      children=node.getchildrens()
      for i,child in enumerate(children):
        if child is not None:
          newChild=node.add_child(value=node.value+'-'+str(i),
                                  state=child, operator=i)
          pq.put((newChild.heuristic(),newChild))
          if endState==child:
            return newChild

  ## A*
  def Aasterisk(self,endState):
    self.reinitRoot()
    pq=queue.PriorityQueue()
    pq.put((self.root.h,self.root))
    #print(f"root.h {self.root.h}, root: {self.root.currentNode}")
    while not pq.empty():
      node=pq.get()[1]
      children=node.getchildrens()

      for i,child in enumerate(children):
        if child is not None:

          newChild=node.add_child(value=node.value+'-'+str(i),
                                  state=child, operator=i, modo=node.modo, target=endState,
                                  objective=node.objective)
          pq.put((newChild.f(),newChild))
         # print(f"Imprimiendo la cola {pq.queue}")
          #print(f"Child :{child}")
          if endState==child:
            print(f"Llegamos al nodo final :{child}")
            return newChild

  ## Método para dibujar el árbol
  def draw(self,path):
    graph = pydot.Dot(graph_type='graph')
    nodeGraph=pydot.Node(str(self.root.state)+"-"+str(0),
                          label=str(self.root.state),shape ="circle",
                          style="filled", fillcolor="red")
    graph.add_node(nodeGraph)
    path.pop()
    return self.drawTreeRec(self.root,nodeGraph,graph,0,path.pop(),path)
  ## Método recursivo para dibujar el árbol
  def drawTreeRec(self,r,rootGraph,graph,i,topPath,path):
    if r is not None:
      children=r.children
      for j,child in enumerate(children):
        i=i+1
        color="white"
        if topPath.value==child.value:
          if len(path)>0:topPath=path.pop()
          color='red'
        c=pydot.Node(child.value,label=str(child.state)+r"\n"+r"\n"+"f="+str(child.f()),
                      shape ="circle", style="filled",
                      fillcolor=color)
        graph.add_node(c)
        graph.add_edge(pydot.Edge(rootGraph, c,
                                  label=str(child.operator)+'('+str(child.cost())+')'))
        graph=self.drawTreeRec(child,c,graph,i,topPath,path)  # recursive call
      return graph
    else:
      return graph

"""Heredamos desde la clase nodo, para crear nuestro propio nodo al cual llamaremos Ruta. y definimos nuestra propia heurística."""

from numpy.ma.core import cos
class Ruta(Node):

  edges = gdf_edges
  nodes = gdf_nodes

  def __init__(self,start_node=None, modo=None, target=None, objective=None, **kwargs):
    super(Ruta, self).__init__(**kwargs)
    self.target = target
    self.start_node = start_node
    self.operators=self.gOp()
    self.adj = list(set(self.gAdj()))
    self.modo = modo
    self.h = self.heuristic()
    self.objective = objective

  def set_startNode(self,start_node):
    self.start_node = start_node

  def set_targetNode(self,target_node):
    self.target_node = target_node

  def gAdj(self):     # Esta función nos permite encontrar la lista de adyacencias válidas del nodo
    state=self.state
    self.neigbours = self.edges.loc[self.state][["length"]].reset_index().drop("key", axis=1).values.tolist()
    self.valid_neigbours = []
    [self.valid_neigbours.append(tuple(n)) if n[0] in self.edges.index else None for n in self.neigbours]
    result=[a if not self.repeatStatePath(a) else None for a in self.valid_neigbours]
    return result

  def gOp(self):    # Devolvemos la lista de operadores que corresponden al nodo actual

    self.neigbours = self.edges.loc[self.state][["length"]].reset_index().drop("key", axis=1).values.tolist()
    self.valid_neigbours = []
    [self.valid_neigbours.append(n[0]) if n[0] in self.edges.index else None for n in self.neigbours]
    return self.valid_neigbours

  def getState(self, index):
    if len(self.adj)>0:
        for nodo, d in self.adj:
          if(self.operators[index]==nodo):
             return self.operators[index]
    return None

  def cost(self): # Definimos nuestra función de costo.
    cost1 = 0
    if self.parent is not None:

      for a in self.parent.adj:
        if a[0]==self.state:
          cost1=self.parent.cost()+a[1]
    else:
      cost1=0
    return cost1

  def heuristic(self): # Definimos tres tipos de heurística para nuestro problema.

    currentNodeXY = (gdf_nodes.loc[self.state][["x","y"]].values.tolist())[::-1]
    targetNodeXY = (gdf_nodes.loc[self.target][["x","y"]].values.tolist())[::-1]

    if self.modo == 'length':     # Heurístoca para la ruta más corta

      return haversine(currentNodeXY, targetNodeXY, unit=Unit.METERS) * 10

    if self.modo == 'NoLights':   # Heurística para la ruta que evita más semáforos

      # Con esta heurística penalizamos las rutas que tienen semáforos.

      if gdf_nodes.loc[self.state]['highway'] == "traffic_signals":
        return geodesic(currentNodeXY, targetNodeXY).m * 10000
      else:
        return geodesic(currentNodeXY, targetNodeXY).m * 200

    if self.modo == 'height':    # Heurística para la ruta más directa

        return haversine(currentNodeXY, targetNodeXY, unit=Unit.METERS) * 2

        # En realidad deberíamos usar el retorno de abajo, pero dado a que se tarda demasiado lo simulamos
        # simplemente modificando el factor de multiplicación de la heurística.

        #return haversine(currentNodeXY, targetNodeXY, unit=Unit.METERS) +  getHeight(currentNodeXY, targetNodeXY) * 20

    return 0

  def getNodes(self):
    return self.nodes

"""Aquí escogemos las coordenadas del punto de origen y del punto de destino, con estas coordenadas obtendremos los nodos desde los cuales comenzaremos a explorar"""

# Envigado

#start = (6.1794658,-75.5793409) # EIA Zuñiga
#end =   (6.1569600,-75.5168548) # EIA Palmas
#start = (6.176368, -75.590647)  # #Viva Envigado

# Bello

start=(6.32357,-75.56823) # Puerto Alegre
#end = (6.32608,-75.56511) # Glorieta
#end = (6.32405,-75.56377) # Frmacia
#end = (6.32675,-75.55802) # Fabricato
#end = (6.33004,-75.55790) # HMFS
#end = (6.33347,-75.55756) # Parque
end = (6.34102,-75.54841) # Farmacia Niquia
#end = (6.35013,-75.57360) # Avenida Regional

start_node = ox.distance.nearest_nodes(G, start[1],start[0]) # Buscamos los nodos de las coordernadas
end_node = ox.distance.nearest_nodes(G, end[1],end[0])

print(f"Nodo de inicio {start_node}")
print(f"Nodo Final {end_node}")

"""Creamos los nodos iniciales para cada ruta dependiendo de su heurística [ Estas son: Evitando la mayor cantidad de semáforos, Calculando la menor ruta, o los menores cambios de altitud ]"""

from networkx.algorithms import operators
NoLights =  Ruta(start_node, state=start_node, modo='NoLights', target=end_node, value='inicio', operators=None, objective=end_node)
Distancia = Ruta(start_node, state=start_node, modo='length', target=end_node, value='inicio', operators=None, objective=end_node)
Altura = Ruta(start_node, state=start_node, modo='height', target=end_node, value='inicio', operators=None, objective=end_node)

"""Calculamos las rutas para cada caso dependiendo de la heurística utilizando el algoritmo A*"""

RutaNoLights=Tree(NoLights,NoLights.operators)    # Ruta con menor distancia
RutaDistancia=Tree(Distancia,Distancia.operators) # Ruta con menor cantidad de semáforos
RutaAltura=Tree(Altura,Altura.operators)          # Ruta con menores cambios de altura
# Exploramos los caminos del árbol con el algoritmo A*
R1=RutaNoLights.Aasterisk(end_node)
R2=RutaDistancia.Aasterisk(end_node)
R3=RutaAltura.Aasterisk(end_node)

P1 = RutaNoLights.printPath(R1)
P2 = RutaDistancia.printPath(R2)
P3 = RutaAltura.printPath(R3)

"""Las rutas anteriores devuelven su correspondiente lista de nodos las cuales utilizaremos para dibujarlas en el mapa."""

print("Ruta que evita más semáforos")
ox.plot_graph_route(G, RutaNoLights.ruta, route_linewidth=30, edge_linewidth=5, node_size=0, bgcolor='#ffffff', edge_color='#000000',figsize=(100, 100))
print("Ruta más corta")
ox.plot_graph_route(G, RutaDistancia.ruta, route_linewidth=30, edge_linewidth=5, node_size=0, bgcolor='#ffffff', edge_color='#000000',figsize=(100, 100))
print("Ruta con menores cambios de altitud")
ox.plot_graph_route(G, RutaAltura.ruta, route_linewidth=30, edge_linewidth=5, node_size=0, bgcolor='#ffffff', edge_color='#000000',figsize=(100, 100))

"""Definimos la función coord, la cual nos devuelve una lista de coordenadas para tres puntos de la ruta, que son: Las coordenadas del nodo inicio, Las coordenadas del nodo intermedio de la ruta y las coordenadas del nodo final."""

def coord(Ruta):  # Esta función devuelve una lista con las coordenadas inicial, las del nodo medio y la del nodo final.
      NodoInicio = (gdf_nodes.loc[Ruta.ruta[0]][["x","y"]].values.tolist())[::-1]
      NodoInterMedio = (gdf_nodes.loc[Ruta.ruta[round((len(Ruta.ruta)/2))]][["x","y"]].values.tolist())[::-1]
      NodoFin = (gdf_nodes.loc[Ruta.ruta[len(Ruta.ruta)-1]][["x","y"]].values.tolist())[::-1]
      return [NodoInicio, NodoInterMedio, NodoFin]

"""La función travelTime, nos estima un tiempo de viaje para cada ruta. Esta función utiliza el API de Google Maps para calcular los tiempos de recorrido para cada una de las rutas utilizando los tres nodos de cada ruta, encontrados en el punto anterior."""

def travelTime(route):
  origin = re.sub("\[|\]|\ ","",str(route[0]))
  waypoints = re.sub("\[|\]|\ ","",str(route[1]))
  destination = re.sub("\[|\]|\ ","",str(route[2]))

  API_KEY = "AIzaSyDwycVDMNTyLsqVpuGF946kzjTVsvVNfFc"
  url = "https://maps.googleapis.com/maps/api/directions/json?origin="+origin+"&destination="+destination+"&waypoints="+waypoints+"&key="+API_KEY

  payload={}
  headers = {}

  response = requests.request("GET", url, headers=headers, data=payload)
  response_json = response.json()

  duration = int(response_json['routes'][0]['legs'][0]['duration']['value']) + int(response_json['routes'][0]['legs'][1]['duration']['value'])

  return duration

print(f"El tiempo de viaje según el tráfico para la ruta sin semáforos es: {travelTime(coord(RutaAltura))} Segundos\n")
print(f"El tiempo de viaje según el tráfico para la ruta más corta es: {travelTime(coord(RutaDistancia))} Segundos\n")
print(f"El tiempo de viaje según el tráfico pra la ruta con menos cambios de altitud es: {travelTime(coord(RutaNoLights))} Segundos\n")